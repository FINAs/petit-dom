{"dependencies":[{"name":"./utils","loc":{"line":1,"column":37}}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mount = mount;\nexports.unmount = unmount;\nexports.patch = patch;\nexports.diffChildren = diffChildren;\n\nvar _utils = require(\"./utils\");\n\nconst SVG_NS = \"http://www.w3.org/2000/svg\";\nconst DELAYED_PROPS = { selected: true, value: true, checked: true };\n/**\r\n  TODO: activate full namespaced attributes (not supported in JSX)\r\n  const XML_NS = \"http://www.w3.org/XML/1998/namespace\"\r\n**/\nconst XLINK_NS = \"http://www.w3.org/1999/xlink\";\nconst NS_ATTRS = {\n  show: XLINK_NS,\n  actuate: XLINK_NS,\n  href: XLINK_NS\n};\n\nfunction defShouldUpdate(p1, p2, c1, c2) {\n  if (c1 !== c2) return true;\n  for (var key in p1) {\n    if (p1[key] !== p2[key]) return true;\n  }\n  return false;\n}\n\nfunction mount(c) {\n  var node;\n  if (c._text != null) {\n    node = document.createTextNode(c._text);\n  } else if (c._vnode === true) {\n    const { type, props, content, isSVG } = c;\n    if (typeof type === \"string\") {\n      // TODO : {is} for custom elements\n      var delayedProps;\n      if (!isSVG) {\n        node = document.createElement(type);\n      } else {\n        node = document.createElementNS(SVG_NS, type);\n      }\n      delayedProps = setAttributes(node, props, undefined);\n      if (!(0, _utils.isArray)(content)) {\n        node.appendChild(mount(content));\n      } else {\n        appendChildren(node, content);\n      }\n      if (delayedProps != null) {\n        setProps(node, props, undefined, delayedProps);\n      }\n    } else if ((0, _utils.isComponent)(type)) {\n      node = type.mount(props, content);\n    } else if (typeof type === \"function\") {\n      if ((0, _utils.isComponent)(type.prototype)) {\n        var instance = new type(props, content);\n        node = instance.mount(props, content);\n        c._data = instance;\n      } else {\n        var vnode = type(props, content);\n        node = mount(vnode);\n        c._data = vnode;\n      }\n    }\n  }\n  if (node == null) {\n    throw new Error(\"Unkown node type!\");\n  }\n  c._node = node;\n  return node;\n}\n\nfunction appendChildren(parent, children, start = 0, end = children.length - 1, beforeNode) {\n  while (start <= end) {\n    var ch = children[start++];\n    parent.insertBefore(mount(ch), beforeNode);\n  }\n}\n\nfunction removeChildren(parent, children, start = 0, end = children.length - 1) {\n  let cleared;\n  if (parent.childNodes.length === end - start + 1) {\n    parent.textContent = \"\";\n    cleared = true;\n  }\n  while (start <= end) {\n    var ch = children[start++];\n    if (!cleared) parent.removeChild(ch._node);\n    unmount(ch);\n  }\n}\n\nfunction unmount(ch) {\n  if ((0, _utils.isArray)(ch)) {\n    for (var i = 0; i < ch.length; i++) {\n      unmount(ch[i]);\n    }\n  } else if (ch._vnode === true) {\n    if ((0, _utils.isComponent)(ch.type)) {\n      ch.type.unmount(ch._node);\n    } else if (typeof ch.type === \"function\" && (0, _utils.isComponent)(ch.type.prototype)) {\n      ch._data.unmount(ch._node);\n    } else if (ch.content != null) {\n      unmount(ch.content);\n    }\n  }\n}\n\nfunction setProps(el, props, oldProps, keys) {\n  var key;\n  for (var i = 0; i < keys.length; i++) {\n    key = keys[i];\n    var oldv = oldProps && oldProps[key];\n    var newv = props[key];\n    if (oldv !== newv) {\n      el[key] = newv;\n    }\n  }\n}\n\nfunction setAttributes(el, attrs, oldAttrs) {\n  let props = [];\n  for (var key in attrs) {\n    if (key.startsWith(\"on\") || key in DELAYED_PROPS) {\n      props.push(key);\n      continue;\n    }\n    var oldv = oldAttrs != null ? oldAttrs[key] : undefined;\n    var newv = attrs[key];\n    if (oldv !== newv) {\n      setDOMAttr(el, key, newv);\n    }\n  }\n  for (key in oldAttrs) {\n    if (!(key in attrs)) {\n      el.removeAttribute(key);\n    }\n  }\n  if (props.length > 0) {\n    return props;\n  }\n}\n\nfunction setDOMAttr(el, attr, value) {\n  if (value === true) {\n    el.setAttribute(attr, \"\");\n  } else if (value === false) {\n    el.removeAttribute(attr);\n  } else {\n    var ns = NS_ATTRS[attr];\n    if (ns !== undefined) {\n      el.setAttributeNS(ns, attr, value);\n    } else {\n      el.setAttribute(attr, value);\n    }\n  }\n}\n\nfunction patch(newch, oldch, parent) {\n  var childNode = oldch._node;\n\n  if (oldch === newch) {\n    return childNode;\n  }\n\n  var t1, t2;\n  if ((t1 = oldch._text) != null && (t2 = newch._text) != null) {\n    if (t1 !== t2) {\n      childNode.nodeValue = t2;\n    }\n  } else if (oldch.type === newch.type && oldch.isSVG === newch.isSVG) {\n    const { type } = oldch;\n    if ((0, _utils.isComponent)(type)) {\n      type.patch(childNode, newch.props, oldch.props, newch.content, oldch.content);\n    } else if (typeof type === \"function\") {\n      if ((0, _utils.isComponent)(type.prototype)) {\n        var instance = oldch._data;\n        instance.patch(childNode, newch.props, oldch.props, newch.content, oldch.content);\n        newch._data = instance;\n      } else {\n        var shouldUpdateFn = type.shouldUpdate || defShouldUpdate;\n        if (shouldUpdateFn(newch.props, oldch.props, newch.content, oldch.content)) {\n          var vnode = type(newch.props, newch.content);\n          childNode = patch(vnode, oldch._data, parent);\n          newch._data = vnode;\n        } else {\n          newch._data = oldch._data;\n        }\n      }\n    } else if (typeof type === \"string\") {\n      var delayedProps = setAttributes(childNode, newch.props, oldch.props);\n      patchContent(childNode, newch.content, oldch.content);\n      if (delayedProps != null) {\n        setProps(childNode, newch.props, oldch.props, delayedProps);\n      }\n    } else {\n      throw new Error(\"Unkown node type! \" + type);\n    }\n  } else {\n    childNode = mount(newch);\n    if (parent) {\n      parent.replaceChild(childNode, oldch._node);\n    }\n  }\n\n  newch._node = childNode;\n  return childNode;\n}\n\nfunction patchContent(parent, content, oldContent) {\n  if (!(0, _utils.isArray)(content) && !(0, _utils.isArray)(oldContent)) {\n    if (content !== oldContent) {\n      patch(content, oldContent, parent);\n    }\n  } else if ((0, _utils.isArray)(content) && (0, _utils.isArray)(oldContent)) {\n    diffChildren(parent, content, oldContent);\n  } else {\n    removeChildren(parent, oldContent, 0, oldContent.length - 1);\n    appendChildren(parent, content);\n  }\n}\n\nfunction canPatch(v1, v2) {\n  return v1.key === v2.key;\n}\n\nfunction diffChildren(parent, children, oldChildren, newStart = 0, newEnd = children.length - 1, oldStart = 0, oldEnd = oldChildren.length - 1) {\n  if (children === oldChildren) return;\n  var oldCh;\n\n  /**\r\n    Before applying the diff algorithm we try some preprocessing optimizations\r\n    to reduce the cost\r\n    See https://neil.fraser.name/writing/diff/ for the full details.\r\n      In the following : indel = INsertion/DELetion\r\n  **/\n\n  // common prefix/suffix\n\n  var k = diffCommonPrefix(children, oldChildren, newStart, newEnd, oldStart, oldEnd, canPatch, parent);\n  newStart += k;\n  oldStart += k;\n\n  k = diffCommonSufffix(children, oldChildren, newStart, newEnd, oldStart, oldEnd, canPatch, parent);\n  newEnd -= k;\n  oldEnd -= k;\n\n  if (newStart > newEnd && oldStart > oldEnd) {\n    return;\n  }\n\n  // simple indel: one of the 2 sequences is empty after common prefix/suffix removal\n\n  // old sequence is empty -> insertion\n  if (newStart <= newEnd && oldStart > oldEnd) {\n    oldCh = oldChildren[oldStart];\n    appendChildren(parent, children, newStart, newEnd, oldCh && oldCh._node);\n    return;\n  }\n\n  // new sequence is empty -> deletion\n  if (oldStart <= oldEnd && newStart > newEnd) {\n    removeChildren(parent, oldChildren, oldStart, oldEnd);\n    return;\n  }\n\n  // 2 simple indels: the shortest sequence is a subsequence of the longest\n  var oldRem = oldEnd - oldStart + 1;\n  var newRem = newEnd - newStart + 1;\n  k = -1;\n  if (oldRem < newRem) {\n    k = indexOf(children, oldChildren, newStart, newEnd, oldStart, oldEnd, canPatch);\n    if (k >= 0) {\n      oldCh = oldChildren[oldStart];\n      appendChildren(parent, children, newStart, k - 1, oldCh._node);\n      var upperLimit = k + oldRem;\n      newStart = k;\n      while (newStart < upperLimit) {\n        patch(children[newStart++], oldChildren[oldStart++]);\n      }\n      oldCh = oldChildren[oldEnd];\n      appendChildren(parent, children, newStart, newEnd, oldCh && oldCh._node.nextSibling);\n      return;\n    }\n  } else if (oldRem > newRem) {\n    k = indexOf(oldChildren, children, oldStart, oldEnd, newStart, newEnd, canPatch);\n    if (k >= 0) {\n      removeChildren(parent, oldChildren, oldStart, k - 1);\n      upperLimit = k + newRem;\n      oldStart = k;\n      while (oldStart < upperLimit) {\n        patch(children[newStart++], oldChildren[oldStart++]);\n      }\n      removeChildren(parent, oldChildren, oldStart, oldEnd);\n      return;\n    }\n  }\n\n  // fast case: difference between the 2 sequences is only one item\n  if (oldStart === oldEnd) {\n    var node = oldChildren[oldStart]._node;\n    appendChildren(parent, children, newStart, newEnd, node);\n    parent.removeChild(node);\n    unmount(node);\n    return;\n  }\n  if (newStart === newEnd) {\n    parent.insertBefore(mount(children[newStart]), oldChildren[oldStart]._node);\n    removeChildren(parent, oldChildren, oldStart, oldEnd);\n    return;\n  }\n\n  /*\r\n    last preopt\r\n    if we can find a subsequence that's at least half the longest sequence the it's guaranteed to\r\n    be the longest common subsequence. This allows us to find the lcs using a simple O(N) algorithm\r\n  */\n  var hm;\n  /*var oldShorter = oldRem < newRem;\r\n  if (oldShorter) {\r\n    hm = diffHalfMatch(\r\n      children,\r\n      oldChildren,\r\n      newStart,\r\n      newEnd,\r\n      oldStart,\r\n      oldEnd,\r\n      canPatch\r\n    );\r\n  } else {\r\n    hm = diffHalfMatch(\r\n      oldChildren,\r\n      children,\r\n      oldStart,\r\n      oldEnd,\r\n      newStart,\r\n      newEnd,\r\n      canPatch\r\n    );\r\n  }\r\n  if (hm) {\r\n    var newStartHm = oldShorter ? hm.start1 : hm.start2;\r\n    var newEndHm = newStartHm + hm.length - 1;\r\n    var oldStartHm = oldShorter ? hm.start2 : hm.start1;\r\n    var oldEndHm = oldStartHm + hm.length - 1;\r\n    for (var i = newStartHm, j = oldStartHm; i <= newEndHm; i++, j++) {\r\n      patch(children[i], oldChildren[j], parent);\r\n    }\r\n    diffChildren(\r\n      parent,\r\n      children,\r\n      oldChildren,\r\n      newStart,\r\n      newStartHm - 1,\r\n      oldStart,\r\n      oldStartHm - 1\r\n    );\r\n    diffChildren(\r\n      parent,\r\n      children,\r\n      oldChildren,\r\n      newEndHm + 1,\r\n      newEnd,\r\n      oldEndHm + 1,\r\n      oldEnd\r\n    );\r\n    return;\r\n  }*/\n\n  /*\r\n    Run the diff algorithm\r\n    First try the O(ND) algorithm. If O(ND) cost is high (Too match diffs between the 2 seqs)\r\n    then fallback to Map lookup based algorithm\r\n  */\n  if (!hm) {\n    var failed = diffOND(parent, children, oldChildren, newStart, newEnd, oldStart, oldEnd);\n    if (failed) diffWithMap(parent, children, oldChildren, newStart, newEnd, oldStart, oldEnd);\n  }\n}\n\nfunction diffCommonPrefix(s1, s2, start1, end1, start2, end2, eq, parent) {\n  var k = 0,\n      c1,\n      c2;\n  while (start1 <= end1 && start2 <= end2 && eq(c1 = s1[start1], c2 = s2[start2])) {\n    if (parent) patch(c1, c2, parent);\n    start1++;\n    start2++;\n    k++;\n  }\n  return k;\n}\n\nfunction diffCommonSufffix(s1, s2, start1, end1, start2, end2, eq, parent) {\n  var k = 0,\n      c1,\n      c2;\n  while (start1 <= end1 && start2 <= end2 && eq(c1 = s1[end1], c2 = s2[end2])) {\n    if (parent) patch(c1, c2, parent);\n    end1--;\n    end2--;\n    k++;\n  }\n  return k;\n}\n/*\r\nfunction diffHalfMatch(s1, s2, start1, end1, start2, end2, eq) {\r\n  var len1 = end1 - start1 + 1;\r\n  var len2 = end2 - start2 + 1;\r\n\r\n  if (len1 < 2 || len2 < 1) {\r\n    return null;\r\n  }\r\n\r\n  var hm1 = halfMatchInt(start1 + Math.ceil(len1 / 4));\r\n  var hm2 = halfMatchInt(start1 + Math.ceil(len1 / 2));\r\n  return !hm1 && !hm2\r\n    ? null\r\n    : !hm1 ? hm2 : !hm2 ? hm1 : hm1.length > hm2.length ? hm1 : hm2;\r\n\r\n  function halfMatchInt(seedStart) {\r\n    var seedEnd = seedStart + Math.floor(len1 / 4);\r\n    var j = start2 - 1;\r\n    var bestCS = { length: 0 };\r\n    while (\r\n      j < end2 &&\r\n      (j = indexOf(s2, s1, j + 1, end2, seedStart, seedEnd, eq)) !== -1\r\n    ) {\r\n      var prefixLen = diffCommonPrefix(s1, s2, seedStart, end1, j, end2, eq);\r\n      var suffixLen = diffCommonSufffix(\r\n        s1,\r\n        s2,\r\n        start1,\r\n        seedStart - 1,\r\n        start2,\r\n        j - 1,\r\n        eq\r\n      );\r\n      if (bestCS.length < prefixLen + suffixLen) {\r\n        bestCS.start1 = seedStart - suffixLen;\r\n        bestCS.start2 = j - suffixLen;\r\n        bestCS.length = prefixLen + suffixLen;\r\n      }\r\n    }\r\n    return bestCS.length >= len1 / 2 ? bestCS : null;\r\n  }\r\n}\r\n*/\nconst PATCH = 2;\nconst INSERTION = 4;\nconst DELETION = 8;\n\n/**\r\n  Find the shortest edit script between the old and new sequences\r\n  This is equivalent to finding the shortest path in the edit graph of the 2 sequences\r\n  see \"An O(ND) Difference Algorithm and Its Variations\" at\r\n  http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.4.6927&rep=rep1&type=pdf\r\n**/\nfunction diffOND(parent, children, oldChildren, newStart = 0, newEnd = children.length - 1, oldStart = 0, oldEnd = oldChildren.length - 1) {\n  var rows = newEnd - newStart + 1;\n  var cols = oldEnd - oldStart + 1;\n  var dmax = rows + cols;\n\n  var v = [];\n  var d, k, r, c, pv, cv, pd;\n  outer: for (d = 0; d <= dmax; d++) {\n    if (d > 50) return true;\n    pd = d - 1;\n    pv = d ? v[d - 1] : [0, 0];\n    cv = v[d] = [];\n    for (k = -d; k <= d; k += 2) {\n      if (k === -d || k !== d && pv[pd + k - 1] < pv[pd + k + 1]) {\n        c = pv[pd + k + 1];\n      } else {\n        c = pv[pd + k - 1] + 1;\n      }\n      r = c - k;\n      while (c < cols && r < rows && canPatch(oldChildren[oldStart + c], children[newStart + r])) {\n        c++;\n        r++;\n      }\n      if (c === cols && r === rows) {\n        break outer;\n      }\n      cv[d + k] = c;\n    }\n  }\n\n  var diff = Array(d / 2 + dmax / 2);\n  var deleteMap = {};\n  var oldCh;\n  var diffIdx = diff.length - 1;\n  for (d = v.length - 1; d >= 0; d--) {\n    while (c > 0 && r > 0 && canPatch(oldChildren[oldStart + c - 1], children[newStart + r - 1])) {\n      // diagonal edge = equality\n      diff[diffIdx--] = PATCH;\n      c--;\n      r--;\n    }\n    if (!d) break;\n    pd = d - 1;\n    pv = d ? v[d - 1] : [0, 0];\n    k = c - r;\n    if (k === -d || k !== d && pv[pd + k - 1] < pv[pd + k + 1]) {\n      // vertical edge = insertion\n      r--;\n      diff[diffIdx--] = INSERTION;\n    } else {\n      // horizontal edge = deletion\n      c--;\n      diff[diffIdx--] = DELETION;\n      oldCh = oldChildren[oldStart + c];\n      if (oldCh.key != null) {\n        deleteMap[oldCh.key] = oldStart + c;\n      }\n    }\n  }\n\n  applyDiff(parent, diff, children, oldChildren, newStart, oldStart, deleteMap);\n}\n\nfunction applyDiff(parent, diff, children, oldChildren, newStart, oldStart, deleteMap) {\n  var ch,\n      oldCh,\n      node,\n      oldMatchIdx,\n      moveMap = {};\n  for (var i = 0, chIdx = newStart, oldChIdx = oldStart; i < diff.length; i++) {\n    const op = diff[i];\n    if (op === PATCH) {\n      patch(children[chIdx++], oldChildren[oldChIdx++], parent);\n    } else if (op === INSERTION) {\n      ch = children[chIdx++];\n      oldMatchIdx = null;\n      if (ch.key != null) {\n        oldMatchIdx = deleteMap[ch.key];\n      }\n      if (oldMatchIdx != null) {\n        node = patch(ch, oldChildren[oldMatchIdx]);\n        moveMap[ch.key] = oldMatchIdx;\n      } else {\n        node = mount(ch);\n      }\n      parent.insertBefore(node, oldChIdx < oldChildren.length ? oldChildren[oldChIdx]._node : null);\n    } else if (op === DELETION) {\n      oldChIdx++;\n    }\n  }\n\n  for (i = 0, oldChIdx = oldStart; i < diff.length; i++) {\n    const op = diff[i];\n    if (op === PATCH) {\n      oldChIdx++;\n    } else if (op === DELETION) {\n      oldCh = oldChildren[oldChIdx++];\n      if (oldCh.key == null || moveMap[oldCh.key] == null) {\n        parent.removeChild(oldCh._node);\n        unmount(oldCh);\n      }\n    }\n  }\n}\n\n/**\r\n  A simplified implementation of Hunt-Szymanski algorithm\r\n  see \"A Fast Algorithm for Computing Longest Common Subsequences\"\r\n  http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.608.1614&rep=rep1&type=pdf\r\n  This implementation supposes keys are unique so we only use \r\n  simple object maps to build the match list\r\n**/\nfunction diffWithMap(parent, children, oldChildren, newStart, newEnd, oldStart, oldEnd) {\n  var keymap = {},\n      unkeyed = [],\n      idxUnkeyed = 0,\n      ch,\n      oldCh,\n      k,\n      idxInOld,\n      key;\n\n  var newLen = newEnd - newStart + 1;\n  var oldLen = oldEnd - oldStart + 1;\n  var minLen = Math.min(newLen, oldLen);\n  var tresh = Array(minLen + 1);\n  tresh[0] = -1;\n\n  for (var i = 1; i < tresh.length; i++) {\n    tresh[i] = oldEnd + 1;\n  }\n  var link = Array(minLen);\n\n  for (i = oldStart; i <= oldEnd; i++) {\n    oldCh = oldChildren[i];\n    key = oldCh.key;\n    if (key != null) {\n      keymap[key] = i;\n    } else {\n      unkeyed.push(i);\n    }\n  }\n\n  for (i = newStart; i <= newEnd; i++) {\n    ch = children[i];\n    idxInOld = ch.key == null ? unkeyed[idxUnkeyed++] : keymap[ch.key];\n    if (idxInOld != null) {\n      k = findK(tresh, idxInOld);\n      if (k >= 0) {\n        tresh[k] = idxInOld;\n        link[k] = { newi: i, oldi: idxInOld, prev: link[k - 1] };\n      }\n    }\n  }\n\n  k = tresh.length - 1;\n  while (tresh[k] > oldEnd) k--;\n\n  var ptr = link[k];\n  var diff = Array(oldLen + newLen - k);\n  var curNewi = newEnd,\n      curOldi = oldEnd;\n  var d = diff.length - 1;\n  while (ptr) {\n    const { newi, oldi } = ptr;\n    while (curNewi > newi) {\n      diff[d--] = INSERTION;\n      curNewi--;\n    }\n    while (curOldi > oldi) {\n      diff[d--] = DELETION;\n      curOldi--;\n    }\n    diff[d--] = PATCH;\n    curNewi--;\n    curOldi--;\n    ptr = ptr.prev;\n  }\n  while (curNewi >= newStart) {\n    diff[d--] = INSERTION;\n    curNewi--;\n  }\n  while (curOldi >= oldStart) {\n    diff[d--] = DELETION;\n    curOldi--;\n  }\n  applyDiff(parent, diff, children, oldChildren, newStart, oldStart, keymap);\n}\n\nfunction findK(ktr, j) {\n  var lo = 1;\n  var hi = ktr.length - 1;\n  while (lo <= hi) {\n    var mid = Math.ceil((lo + hi) / 2);\n    if (j < ktr[mid]) hi = mid - 1;else lo = mid + 1;\n  }\n  return lo;\n}\n\nfunction indexOf(a, suba, aStart, aEnd, subaStart, subaEnd, eq) {\n  var j = subaStart,\n      k = -1;\n  var subaLen = subaEnd - subaStart + 1;\n  while (aStart <= aEnd && aEnd - aStart + 1 >= subaLen) {\n    if (eq(a[aStart], suba[j])) {\n      if (k < 0) k = aStart;\n      j++;\n      if (j > subaEnd) return k;\n    } else {\n      k = -1;\n      j = subaStart;\n    }\n    aStart++;\n  }\n  return -1;\n}"},"hash":"fb71518adc6d926f602d01b93f92137f"}