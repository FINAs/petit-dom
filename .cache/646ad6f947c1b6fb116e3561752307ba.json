{"dependencies":[{"name":"tape","loc":{"line":1,"column":17}},{"name":"../src","loc":{"line":2,"column":32}}],"generated":{"js":"\"use strict\";\n\nvar _tape = require(\"tape\");\n\nvar _tape2 = _interopRequireDefault(_tape);\n\nvar _src = require(\"../src\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n//  Fisher-Yates Shuffle\n// code from https://stackoverflow.com/a/6274398/1430627\nfunction shuffle(array) {\n  let counter = array.length;\n\n  // While there are elements in the array\n  while (counter > 0) {\n    // Pick a random index\n    let index = Math.floor(Math.random() * counter);\n\n    // Decrease counter by 1\n    counter--;\n\n    // And swap the last element with it\n    let temp = array[counter];\n    array[counter] = array[index];\n    array[index] = temp;\n  }\n\n  return array;\n}\n\n(0, _tape2.default)(\"text node\", assert => {\n  const vnode = { _text: \"old text\" };\n  const node = (0, _src.mount)(vnode);\n\n  const vnode2 = { _text: \"new text\" };\n  const node2 = (0, _src.patch)(vnode2, vnode);\n\n  assert.equal(node, node2);\n  assert.equal(vnode2._node, node);\n  assert.equal(node.nodeValue, \"new text\");\n\n  assert.end();\n});\n\n(0, _tape2.default)(\"patch node with different types\", assert => {\n  const vnode = { _text: \"old text\" };\n  const node = (0, _src.mount)(vnode);\n\n  const vnode2 = (0, _src.h)(\"span\");\n  const node2 = (0, _src.patch)(vnode2, vnode);\n\n  assert.notEqual(node, node2);\n  assert.equal(vnode2._node, node2);\n  assert.equal(node2.tagName, \"SPAN\");\n\n  const vnode3 = (0, _src.h)(\"div\");\n  const node3 = (0, _src.patch)(vnode3, vnode2);\n\n  assert.notEqual(node2, node3);\n  assert.equal(vnode3._node, node3);\n  assert.equal(node3.tagName, \"DIV\");\n\n  assert.end();\n});\n\n(0, _tape2.default)(\"patch props\", assert => {\n  const vnode = (0, _src.h)(\"input\", {\n    type: \"text\",\n    value: \"old value\",\n    style: \"color: red\"\n  });\n  const node = (0, _src.mount)(vnode);\n\n  const vnode2 = (0, _src.h)(\"input\", {\n    type: \"text\",\n    value: \"new value\",\n    style: \"color: green; border: 1px solid black\"\n  });\n  const node2 = (0, _src.patch)(vnode2, vnode);\n\n  assert.equal(node2, node);\n  assert.equal(vnode2._node, node);\n  assert.equal(node.type, \"text\");\n  assert.equal(node.value, \"new value\");\n  assert.equal(node.style.color, \"green\");\n  assert.equal(node.style.border, \"1px solid black\");\n\n  assert.end();\n});\n\n(0, _tape2.default)(\"patch attributes (svg)\", assert => {\n  const vnode = (0, _src.h)(\"div\", null, (0, _src.h)(\"span\", null, \"...\"), (0, _src.h)(\"svg\", null, (0, _src.h)(\"circle\", { cx: 50, cy: 60, r: 30 })), (0, _src.h)(\"span\", null, \"...\"));\n  const node = (0, _src.mount)(vnode);\n  let svgCircle = node.childNodes[1].firstChild;\n  assert.equal(svgCircle.getAttribute(\"cx\"), \"50\");\n  assert.equal(svgCircle.getAttribute(\"cy\"), \"60\");\n  assert.equal(svgCircle.getAttribute(\"r\"), \"30\");\n\n  const onclick = () => {};\n  const vnode2 = (0, _src.h)(\"div\", null, (0, _src.h)(\"span\", null, \"...\"), (0, _src.h)(\"svg\", null, (0, _src.h)(\"circle\", { cx: 50, cy: 40, stroke: \"green\", fill: \"yellow\" })), (0, _src.h)(\"span\", { onclick }, \"...\"));\n\n  (0, _src.patch)(vnode2, vnode);\n  assert.equal(svgCircle.getAttribute(\"cx\"), \"50\");\n  assert.equal(svgCircle.getAttribute(\"cy\"), \"40\");\n  assert.equal(svgCircle.getAttribute(\"stroke\"), \"green\");\n  assert.equal(svgCircle.getAttribute(\"fill\"), \"yellow\");\n  assert.equal(svgCircle.hasAttribute(\"r\"), false);\n\n  const span = node.childNodes[2];\n  assert.equal(span.onclick, onclick, \"should patch props instead of attributes once svg context is off\");\n\n  assert.end();\n});\n\n(0, _tape2.default)(\"patch non keyed children\", assert => {\n  const render = s => (0, _src.h)(\"div\", null, s.split(\"\"));\n\n  let vnode, vnode2, node;\n  vnode = (0, _src.h)(\"div\");\n  node = (0, _src.mount)(vnode);\n\n  function testPatch(seq, message) {\n    assert.test(message, assert => {\n      vnode2 = render(seq);\n      (0, _src.patch)(vnode2, vnode);\n      vnode = vnode2;\n      assert.plan(vnode.content.length * 2 + 1);\n\n      assert.equal(node.childNodes.length, vnode.content.length, \"should have same number of children\");\n      for (var i = 0; i < vnode.content.length; i++) {\n        const ch = vnode.content[i];\n        const childNode = node.childNodes[i];\n\n        assert.equal(childNode.nodeName, \"#text\", \"chuild should be a text node\");\n        assert.equal(childNode.nodeValue, ch._text, \"should patch text content\");\n      }\n    });\n    //assert.end()\n  }\n\n  testPatch(\"36\", \"append to an empty sequence\");\n  testPatch(\"3678\", \"append\");\n  testPatch(\"123678\", \"prepend\");\n  testPatch(\"12345678\", \"insert in the middle\");\n  testPatch(\"A0123456789B\", \"append + prepend\");\n  testPatch(\"12345678\", \"remove from edges\");\n  testPatch(\"123678\", \"remove from middle\");\n  testPatch(\"2x3y67z8\", \"multiple modificationq\");\n  testPatch(shuffle(\"2x3y67z8\".split(\"\")).join(\"\"), \"shuffle\");\n  testPatch(\"ABCDEF\", \"replace all\");\n  testPatch(\"\", \"clear\");\n\n  assert.end();\n});\n\n(0, _tape2.default)(\"patch keyed children\", assert => {\n  const render = str => (0, _src.h)(\"div\", null, str.split(\"\").map(c => (0, _src.h)(\"span\", { key: c }, c)));\n\n  let prevVNode,\n      vnode = render(\"\"),\n      node = (0, _src.mount)(vnode);\n\n  function testPatch(s, message) {\n    assert.test(message, assert => {\n      prevVNode = vnode;\n      vnode = render(s);\n\n      const findOldByKey = key => prevVNode.content.find(vn => vn.key === key);\n\n      (0, _src.patch)(vnode, prevVNode);\n\n      assert.plan(vnode.content.length * 2 + 1);\n      assert.equal(node.childNodes.length, vnode.content.length);\n\n      for (var i = 0; i < vnode.content.length; i++) {\n        const ch = vnode.content[i];\n        const childNode = node.childNodes[i];\n        assert.equal(childNode, ch._node, ch.key + \" should match real DOM node\");\n        const oldVNode = findOldByKey(ch.key);\n        if (oldVNode != null) {\n          assert.equal(oldVNode._node, ch._node, \"should preserve DOM node\");\n        } else {\n          assert.ok(true, \"new node\");\n        }\n      }\n    });\n  }\n\n  testPatch(\"36\", \"append to an empty sequence\");\n  testPatch(\"3678\", \"append\");\n  testPatch(\"7836\", \"reorder\");\n  testPatch(\"3678\", \"reorde(2)\");\n  testPatch(\"123678\", \"prepend\");\n  testPatch(\"12345678\", \"insert in the middle\");\n  testPatch(\"A0123456789B\", \"append + prepend\");\n  testPatch(\"12345678\", \"remove from edges\");\n  testPatch(\"123678\", \"remove from middle\");\n  testPatch(\"2x6y37z8\", \"multiple modifications\");\n  testPatch(shuffle(\"2x6y37z8\".split(\"\")).join(\"\"), \"shuffle\");\n  testPatch(\"ABCDEF\", \"replace all\");\n  testPatch(\"\", \"clear\");\n\n  assert.end();\n});\n\n(0, _tape2.default)(\"patch render functions\", assert => {\n  let renderCalls = 0;\n\n  function Box(props, content) {\n    renderCalls++;\n    return (0, _src.h)(\"h1\", { title: props.title }, content);\n  }\n\n  const vnode = (0, _src.h)(Box, { title: \"box title\" }, \"box content\");\n  const node = (0, _src.mount)(vnode);\n  assert.equal(renderCalls, 1, \"mount should invoke render function\");\n  assert.equal(vnode._node, node);\n\n  const vnode2 = (0, _src.h)(Box, { title: \"another box title\" }, \"another box content\");\n  (0, _src.patch)(vnode2, vnode);\n  assert.equal(renderCalls, 2, \"patch should invoke render function\");\n  assert.equal(vnode2._node, node);\n  assert.equal(node.title, \"another box title\");\n  assert.equal(node.firstChild.nodeValue, \"another box content\");\n\n  const vnode3 = (0, _src.h)(Box, { title: \"another box title\" }, \"another box content\");\n  (0, _src.patch)(vnode3, vnode2);\n  assert.equal(renderCalls, 2, \"patch should not invoke render function if props & content have not changed\");\n  assert.equal(vnode3._node, node);\n  assert.equal(node.title, \"another box title\");\n  assert.equal(node.firstChild.nodeValue, \"another box content\");\n\n  assert.end();\n});\n\n(0, _tape2.default)(\"Patch Component\", assert => {\n  let patchCalls = 0;\n\n  const MyComponent = {\n    mount: (props, content) => {\n      var node = document.createElement(\"my-component\");\n      node._payload = [props, content];\n      return node;\n    },\n    patch: (node, props, oldProps, content, oldContent) => {\n      patchCalls++;\n      node._payload = [props, content];\n      assert.deepEqual(oldProps, vnode.props);\n      assert.deepEqual(oldContent, vnode.content);\n      return node;\n    },\n    unmount: () => {}\n  };\n\n  const vnode = (0, _src.h)(MyComponent, { some_prop: \"some prop\" }, { some_cont: \"some content\" });\n\n  const node = (0, _src.mount)(vnode);\n  assert.equal(vnode._node, node);\n  assert.deepEqual(node._payload, [vnode.props, vnode.content]);\n\n  const vnode2 = (0, _src.h)(MyComponent, { some_prop: \"another prop\" }, { some_cont: \"another content\" });\n  (0, _src.patch)(vnode2, vnode);\n  assert.equal(vnode2._node, node);\n  assert.equal(patchCalls, 1, \"patch should invoke Component.patch\");\n  assert.deepEqual(node._payload, [vnode2.props, vnode2.content]);\n\n  assert.end();\n});"},"hash":"cc484e10ec6653c80adb1dcc7e8fc8f2"}